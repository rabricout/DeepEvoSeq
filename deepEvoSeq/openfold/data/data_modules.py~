import copy
from functools import partial
import json
import logging
import os
import pickle
from typing import Optional, Sequence, List, Any

import ml_collections as mlc
import pytorch_lightning as pl
import torch
from torch.utils.data import RandomSampler

from openfold.data import (
    data_pipeline,
    feature_pipeline,
    mmcif_parsing,
    templates,
)
from openfold.utils.tensor_utils import tensor_tree_map, dict_multimap

# RAPH: imports for custom feats
import gzip
import time
import shutil
import random
import numpy as np
import openfold.np.residue_constants as residue_constants
from Bio import SeqIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from openfold.utils.my_functions import my_align_seqs
import subprocess


class OpenFoldSingleDataset(torch.utils.data.Dataset):
    def __init__(self,
        precomputed_data_dir: str,
        #alignment_dir: str, 
        #template_mmcif_dir: str,
        max_template_date: str,
        #label_dir: str,    # RAPH 
        #anchor_dir: str,    # RAPH
        #precomputed_dir: str,    # RAPH
        config: mlc.ConfigDict,
        #chain_data_cache_path: Optional[str] = None,
        kalign_binary_path: str = '/usr/bin/kalign',
        max_template_hits: int = 4,
        obsolete_pdbs_file_path: Optional[str] = None,
        template_release_dates_cache_path: Optional[str] = None,
        #shuffle_top_k_prefiltered: Optional[int] = None,
        treat_pdb_as_distillation: bool = True,
        filter_path: Optional[str] = None,
        mode: str = "train", 
        alignment_index: Optional[Any] = None,
        _output_raw: bool = False,
        _structure_index: Optional[Any] = None,
    ):
        """
            Args:
                precomputed_data_dir:
                    A path to a directory containing preocmputed AlphaFold features
                data_dir:
                    A path to a directory containing mmCIF files (in train
                    mode) or FASTA files (in inference mode).
                alignment_dir:
                    A path to a directory containing only data in the format 
                    output by an AlignmentRunner 
                    (defined in openfold.features.alignment_runner).
                    I.e. a directory of directories named {PDB_ID}_{CHAIN_ID}
                    or simply {PDB_ID}, each containing .a3m, .sto, and .hhr
                    files.
                template_mmcif_dir:
                    Path to a directory containing template mmCIF files.
                config:
                    A dataset config object. See openfold.config
                chain_data_cache_path:
                    Path to cache of data_dir generated by
                    scripts/generate_chain_data_cache.py
                kalign_binary_path:
                    Path to kalign binary.
                max_template_hits:
                    An upper bound on how many templates are considered. During
                    training, the templates ultimately used are subsampled
                    from this total quantity.
                template_release_dates_cache_path:
                    Path to the output of scripts/generate_mmcif_cache.
                obsolete_pdbs_file_path:
                    Path to the file containing replacements for obsolete PDBs.
                shuffle_top_k_prefiltered:
                    Whether to uniformly shuffle the top k template hits before
                    parsing max_template_hits of them. Can be used to
                    approximate DeepMind's training-time template subsampling
                    scheme much more performantly.
                treat_pdb_as_distillation:
                    Whether to assume that .pdb files in the data_dir are from
                    the self-distillation set (and should be subjected to
                    special distillation set preprocessing steps).
                mode:
                    "train", "val", or "predict"
        """
        super(OpenFoldSingleDataset, self).__init__()
        #self.data_dir = data_dir

        #self.chain_data_cache = None
        #if chain_data_cache_path is not None:
        #    with open(chain_data_cache_path, "r") as fp:
        #        self.chain_data_cache = json.load(fp)
        #    assert isinstance(self.chain_data_cache, dict)

        #self.alignment_dir = alignment_dir
        self.config = config
        self.treat_pdb_as_distillation = treat_pdb_as_distillation
        self.mode = mode
        self.alignment_index = alignment_index
        self._output_raw = _output_raw
        self._structure_index = _structure_index

        self.supported_exts = [".cif", ".core", ".pdb"]
        
        #self.label_dir = label_dir    # RAPH
        #self.anchor_dir = anchor_dir    # RAPH
        self.precomputed_data_dir = precomputed_data_dir    # RAPH

        valid_modes = ["train", "eval", "predict"]
        if(mode not in valid_modes):
            raise ValueError(f'mode must be one of {valid_modes}')

        if(template_release_dates_cache_path is None):
            logging.warning(
                "Template release dates cache does not exist. Remember to run "
                "scripts/generate_mmcif_cache.py before running OpenFold"
            )

        if(alignment_index is not None):
            self._chain_ids = list(alignment_index.keys())
        else:
            self._chain_ids = list(os.listdir(self.precomputed_data_dir))

        if(filter_path is not None):
            with open(filter_path, "r") as f:
                chains_to_include = set([l.strip() for l in f.readlines()])

            self._chain_ids = [
                c for c in self._chain_ids if c in chains_to_include
            ]

        #if self.chain_data_cache is not None:
        #    # Filter to include only chains where we have structure data
        #    # (entries in chain_data_cache)
        #    original_chain_ids = self._chain_ids
        #    self._chain_ids = [
        #        c for c in self._chain_ids if c in self.chain_data_cache
        #    ]
        #    if len(self._chain_ids) < len(original_chain_ids):
        #        missing = [
        #            c for c in original_chain_ids
        #            if c not in self.chain_data_cache
        #        ]
        #        max_to_print = 10
        #        missing_examples = ", ".join(missing[:max_to_print])
        #        if len(missing) > max_to_print:
        #            missing_examples += ", ..."
        #        logging.warning(
        #            "Removing %d alignment entries (%s) with no corresponding "
        #            "entries in chain_data_cache (%s).",
        #            len(missing),
        #            missing_examples,
        #            chain_data_cache_path)
       
        self._chain_id_to_idx_dict = {
            chain: i for i, chain in enumerate(self._chain_ids)
        }

        template_featurizer = None    # RAPH: we don't need this anymore as long as the data are preprocessed
        #template_featurizer = templates.TemplateHitFeaturizer(
        #    mmcif_dir=template_mmcif_dir,
        #    max_template_date=max_template_date,
        #    max_hits=max_template_hits,
        #    kalign_binary_path=kalign_binary_path,
        #    release_dates_path=template_release_dates_cache_path,
        #    obsolete_pdbs_path=obsolete_pdbs_file_path,
        #    _shuffle_top_k_prefiltered=shuffle_top_k_prefiltered,
        #)       
        
        self.data_pipeline = data_pipeline.DataPipeline(
            template_featurizer=template_featurizer,
        )

        if(not self._output_raw):
            self.feature_pipeline = feature_pipeline.FeaturePipeline(config) 

    def _parse_mmcif(self, path, file_id, chain_id, alignment_dir, alignment_index):
        with open(path, 'r') as f:
            mmcif_string = f.read()

        mmcif_object = mmcif_parsing.parse(
            file_id=file_id, mmcif_string=mmcif_string
        )

        # Crash if an error is encountered. Any parsing errors should have
        # been dealt with at the alignment stage.
        if(mmcif_object.mmcif_object is None):
            raise list(mmcif_object.errors.values())[0]

        mmcif_object = mmcif_object.mmcif_object

        data = self.data_pipeline.process_mmcif(
            mmcif=mmcif_object,
            alignment_dir=alignment_dir,
            chain_id=chain_id,
            alignment_index=alignment_index
        )

        return data

    def chain_id_to_idx(self, chain_id):
        return self._chain_id_to_idx_dict[chain_id]

    def idx_to_chain_id(self, idx):
        return self._chain_ids[idx]

    def __getitem__(self, idx):
        name = self.idx_to_chain_id(idx)
        alignment_dir = os.path.join(self.alignment_dir, name)
        #print(alignment_dir)

        print('DO NOT DO THIS')
        
        alignment_index = None
        if(self.alignment_index is not None):
            alignment_dir = self.alignment_dir
            alignment_index = self.alignment_index[name]

        if(self.mode == 'train' or self.mode == 'eval'):
            spl = name.rsplit('_', 1)
            if(len(spl) == 2):
                file_id, chain_id = spl
            else:
                file_id, = spl
                chain_id = None

            path = os.path.join(self.data_dir, file_id)
            structure_index_entry = None
            if(self._structure_index is not None):
                structure_index_entry = self._structure_index[name]
                assert(len(structure_index_entry["files"]) == 1)
                filename, _, _ = structure_index_entry["files"][0]
                ext = os.path.splitext(filename)[1]
            else:
                ext = None
                for e in self.supported_exts:
                    if(os.path.exists(path + e)):
                        ext = e
                        break

                if(ext is None):
                    raise ValueError("Invalid file type")

            path += ext
            if(ext == ".cif"):
                data = self._parse_mmcif(
                    path, file_id, chain_id, alignment_dir, alignment_index,
                )
            elif(ext == ".core"):
                data = self.data_pipeline.process_core(
                    path, alignment_dir, alignment_index,
                )
            elif(ext == ".pdb"):
                structure_index = None
                if(self._structure_index is not None):
                    structure_index = self._structure_index[name]
                data = self.data_pipeline.process_pdb(
                    pdb_path=path,
                    alignment_dir=alignment_dir,
                    is_distillation=self.treat_pdb_as_distillation,
                    chain_id=chain_id,
                    alignment_index=alignment_index,
                    _structure_index=structure_index,
                )
            else:
               raise ValueError("Extension branch missing") 
        else:
            path = os.path.join(name, name + ".fasta")
            data = self.data_pipeline.process_fasta(
                fasta_path=path,
                alignment_dir=alignment_dir,
                alignment_index=alignment_index,
            )

        if(self._output_raw):
            return data

        feats = self.feature_pipeline.process_features(
            data, self.mode 
        )
        
        feats["batch_idx"] = torch.tensor(
            [idx for _ in range(feats["aatype"].shape[-1])],
            dtype=torch.int64,
            device=feats["aatype"].device)

        # RAPH: adding the custom data, including target and anchor sequences
        
        # define useful dict for alignment
        #aa_to_id_dict = residue_constants.ID_TO_HHBLITS_AA    # dict to use to convert numbers to aa seqs
        #inv_dict = residue_constants.HHBLITS_AA_TO_ID
        #inv_dict = {v: k for k, v in aa_to_id_dict.items()}
        
        # ici, on ajoute comme feature la sequence cible, après l'avoir alignée sur l'input
        label_path = os.path.join(self.label_dir, file_id)
        label_file = label_path+'.fasta'
        label_data = self.data_pipeline.process_fasta(
            fasta_path=label_file,
            alignment_dir=alignment_dir,
            alignment_index=alignment_index,
        )
        labels = np.argmax(label_data['aatype'], 1)
        
        anchor_path = os.path.join(self.anchor_dir, file_id)
        anchor_file = anchor_path+'.fasta'
        anchor_data = self.data_pipeline.process_fasta(
            fasta_path=anchor_file,
            alignment_dir=alignment_dir,
            alignment_index=alignment_index,
        )
        anchors = np.argmax(anchor_data['aatype'], 1)

        seq_input_letters  = SeqRecord(Seq(''.join(aa_to_id_dict[aa.item()] for aa in feats["aatype"][:,0])), description="input")
        seq_labels_letters = SeqRecord(Seq(''.join(aa_to_id_dict[aa.item()] for aa in labels)), description="labels")
        seq_anchor_letters = SeqRecord(Seq(''.join(aa_to_id_dict[aa.item()] for aa in anchors)), description="anchor")
        alignments = my_align_seqs([seq_input_letters, seq_labels_letters, seq_anchor_letters])
        
        input_ali  = alignments[0].seq
        labels_ali = alignments[1].seq
        anchor_ali = alignments[2].seq
        
        labels_filtered = ''
        anchor_filtered = ''
        for i, c in enumerate(input_ali):
            if input_ali[i] != '-':
                labels_filtered += labels_ali[i]
                anchor_filtered += anchor_ali[i]
        labels  = [inv_dict[aa] for aa in labels_filtered]
        anchors = [inv_dict[aa] for aa in anchor_filtered]
        labels  = np.swapaxes([labels]*feats["aatype"].shape[-1],0,1)    # RAPH: Make it the good shape to recycle properly
        anchors = np.swapaxes([anchors]*feats["aatype"].shape[-1],0,1)
        
        feats['label_seq'] = torch.tensor(
            labels, 
            dtype=torch.int64,
            device=feats["aatype"].device)
        feats['anchor_seq'] = torch.tensor(
            anchors, 
            dtype=torch.int64,
            device=feats["aatype"].device)
        
        # do substitution mask
        seq_truth = feats["label_seq"][:,0]
        seq_anchor = feats["anchor_seq"][:,0]
        mask_substitutions = [seq_anchor[i].item()!=seq_truth[i].item() for i in range(len(seq_anchor))]
        mask_substitutions = np.swapaxes([mask_substitutions]*feats["aatype"].shape[-1],0,1)
        feats['mask_substitutions'] = torch.tensor(
            mask_substitutions, 
            dtype=torch.int64,
            device=feats["aatype"].device)
        
        # do indel mask
        mask_indels = [seq_truth[i].item() != 22 and seq_anchor[i].item() != 22 for i in range(len(seq_truth))]
        mask_indels = np.swapaxes([mask_indels]*feats["aatype"].shape[-1],0,1)
        feats['mask_indels'] = torch.tensor(
            mask_indels, 
            dtype=torch.bool,
            device=feats["aatype"].device)

        tmp = feats["residue_index"].tolist()
        residue_index_rev = [0 if tmp[i][0]== 0 and i>0 else feats["raw_seq_length"][0].item()-tmp[i][0] for i in range(len(tmp))]    # RAPH: "if ..." is to have 0 for the padding except if the first value is the first index of the sequence
        residue_index_rev = np.swapaxes([residue_index_rev]*feats["aatype"].shape[-1],0,1)
        feats['residue_index_rev'] = torch.tensor(
            residue_index_rev,
            dtype=torch.int64,
            device=feats["aatype"].device)
        
        # RAPH: additional features have been added
        
        return feats

    def __len__(self):
        return len(self._chain_ids) 


def deterministic_train_filter(
    chain_data_cache_entry: Any,
    max_resolution: float = 9.,
    max_single_aa_prop: float = 0.8,
) -> bool:
    # Hard filters
    resolution = chain_data_cache_entry.get("resolution", None)
    if(resolution is not None and resolution > max_resolution):
        return False

    seq = chain_data_cache_entry["seq"]
    counts = {}
    for aa in seq:
        counts.setdefault(aa, 0)
        counts[aa] += 1
    largest_aa_count = max(counts.values())
    largest_single_aa_prop = largest_aa_count / len(seq)
    if(largest_single_aa_prop > max_single_aa_prop):
        return False

    return True


def get_stochastic_train_filter_prob(
    chain_data_cache_entry: Any,
) -> List[float]:
    # Stochastic filters
    probabilities = []
    
    cluster_size = chain_data_cache_entry.get("cluster_size", None)
    if(cluster_size is not None and cluster_size > 0):
        probabilities.append(1 / cluster_size)
    
    chain_length = len(chain_data_cache_entry["seq"])
    probabilities.append((1 / 512) * (max(min(chain_length, 512), 256)))

    # Risk of underflow here?
    out = 1
    for p in probabilities:
        out *= p

    return out


class OpenFoldDataset(torch.utils.data.Dataset):
    """
        Implements the stochastic filters applied during AlphaFold's training.
        Because samples are selected from constituent datasets randomly, the
        length of an OpenFoldFilteredDataset is arbitrary. Samples are selected
        and filtered once at initialization.
    """
    def __init__(self,
        datasets: Sequence[OpenFoldSingleDataset],
        probabilities: Sequence[float],
        epoch_len: int,
        generator: torch.Generator = None,
        _roll_at_init: bool = True,
    ):
        self.datasets = datasets
        self.probabilities = probabilities
        self.epoch_len = epoch_len
        self.generator = generator

        self.data_list = [os.listdir(d.precomputed_data_dir+'/') for d in self.datasets]
        self.dataset_raw_lengths = [len(d) for d in self.data_list]

        #def looped_shuffled_dataset_idx(dataset_len):
        #    while True:
        #        # Uniformly shuffle each dataset's indices
        #        weights = [1. for _ in range(dataset_len)]
        #        shuf = torch.multinomial(
        #            torch.tensor(weights),
        #            num_samples=dataset_len,
        #            replacement=False,
        #            generator=self.generator,
        #        )
        #        for idx in shuf:
        #            yield idx
        
        #idx_iter = looped_shuffled_dataset_idx(len(dataset))
                    
        #def looped_samples(dataset_idx):
        #    max_cache_len = int(epoch_len * probabilities[dataset_idx])
        #    dataset = self.datasets[dataset_idx]
        #    idx_iter = looped_shuffled_dataset_idx(len(dataset))
        #    chain_data_cache = dataset.chain_data_cache
        #    while True:
        #        weights = []
        #        idx = []
        #        for _ in range(max_cache_len):
        #            candidate_idx = next(idx_iter)
        #            chain_id = dataset.idx_to_chain_id(candidate_idx)
        #            chain_data_cache_entry = chain_data_cache[chain_id]
        #            if(not deterministic_train_filter(chain_data_cache_entry)):
        #                continue

        #            p = get_stochastic_train_filter_prob(
        #                chain_data_cache_entry,
        #            )
        #            p=1
        #            weights.append([1. - p, p])
        #            idx.append(candidate_idx)

        #        samples = torch.multinomial(
        #            torch.tensor(weights),
        #            num_samples=1,
        #            generator=self.generator,
        #        )
        #        samples = samples.squeeze()

        #        cache = [i for i, s in zip(idx, samples) if s]

        #        for datapoint_idx in cache:
        #            yield datapoint_idx
        
        #self._samples = [looped_shuffled_dataset_idx(d) for d in self.dataset_raw_lengths]
        
        if(_roll_at_init):
            self.reroll()

    def looped_shuffled_dataset_idx(self, dataset_len):
        while True:
            # Uniformly shuffle each dataset's indices
            weights = [1. for _ in range(dataset_len)]
            shuf = torch.multinomial(
                torch.tensor(weights),
                num_samples=dataset_len,
                replacement=False,
                generator=self.generator,
            )
            for idx in shuf:
                yield idx

            
    def __getitem__(self, idx):
        # RAPH: modify the access to data, using precomputed ones to speed-up the process
        dataset_idx, datapoint_idx = self.datapoints[idx]
        precomputed_dir = self.datasets[dataset_idx].precomputed_data_dir
        folder_id = self.data_list[dataset_idx][datapoint_idx]

        #while not (os.isdir(precomputed_dir+'/'+str(folder_id)+'/feats') and os.isdir(precomputed_dir+'/'+str(folder_id)+'/outputs')):
        #    dataset_idx, datapoint_idx = self.datapoints[idx]
        #    precomputed_dir = self.datasets[dataset_idx].precomputed_data_dir
        #    folder_id = self.data_list[dataset_idx][datapoint_idx]
        #print(self.datasets[dataset_idx].mode, str(folder_id))
        
        with open(precomputed_dir+str(folder_id)+'/keys_ids', 'r') as keys_file:
            keys = json.load(keys_file)
        with open(precomputed_dir+str(folder_id)+'/values.zip.npz', 'rb') as values_file:
            values = np.load(values_file)
            list_values = [values[f] for f in values.files]
        y = dict(map(lambda i,j : (i,torch.Tensor(j)) , keys, list_values))
        
        #for f_name in os.listdir(precomputed_dir+'/'+str(folder_id)+'/feats'):
        #    f = gzip.GzipFile(precomputed_dir+'/'+str(folder_id)+'/feats/'+f_name, 'r')
        #    yk_np = np.load(file=f)
        #    f.close()
        #    y[f_name] = torch.tensor(yk_np)
        #for f_name in os.listdir(precomputed_dir+'/'+str(folder_id)+'/outputs'):
        #    f = gzip.GzipFile(precomputed_dir+'/'+str(folder_id)+'/outputs/'+f_name, 'r')
        #    yk_np = np.load(file=f)
        #    f.close()
        #    y['__outputs_'+f_name] = torch.tensor(yk_np)
        
        # we add the HM branch
        #s_anchor = y['anchor_seq'][0].int().tolist()
        #s_human  = y['human_seq'][0].int().tolist()
        #s_truth  = y['label_seq'][0].int().tolist()
        #s_mouse  = y['mouse_seq'][0].int().tolist()

        # Building the ancestor using the known sequences
        #if os.path.isdir('WORK/'+str(folder_id)):
        #    shutil.rmtree('WORK/'+str(folder_id))
        #os.makedirs('WORK/'+str(folder_id))
        #with open(os.path.join('WORK', str(folder_id), 'ali.fasta'), 'w') as f:
        #    f.write('>homo_sapiens\n')
        #    f.write(residue_constants.aatype_to_str_sequence(s_human)+'\n')
        #    f.write('>mus_musculus\n')
        #    f.write(residue_constants.aatype_to_str_sequence(s_mouse)+'\n')
        #    f.write('>aplodontia_rufa\n')
        #    f.write(residue_constants.aatype_to_str_sequence(s_truth)+'\n')
        #    f.write('>sciurus_vulgaris\n')
        #    f.write(residue_constants.aatype_to_str_sequence(s_anchor)+'\n')
        #command = ["/import/bc_users/biocomp/bricout/EXEC/bppancestor"]
        #command.append("input.sequence.file="+os.path.join('WORK', str(folder_id),'ali.fasta'))
        #command.append("input.sequence.format=Fasta")
        #command.append("alphabet=Protein")
        #command.append("input.sequence.sites_to_use=all")
        #command.append("input.tree.file="+os.path.join('RESOURCES', 'species_tree.nw'))
        #command.append("input.tree.format=Newick")
        #command.append("param=param.out")
        #command.append("asr.probabilities=no")
        #command.append("output.sites.file="+os.path.join('WORK', str(folder_id), 'sites.out'))
        #command.append("output.sequence.file="+os.path.join('WORK', str(folder_id), 'sequence.out'))
        #subprocess.run(command, stdout = subprocess.DEVNULL)

        #ancestorRecords = list(SeqIO.parse(os.path.join('WORK', str(folder_id), 'sequence.out'), "fasta"))
        #if ancestorRecords[0].id == '3':    # get the closest ancestor
        #    ancestor_str = ancestorRecords[0].seq
        #elif ancestorRecords[1].id == '3':
        #    ancestor_str = ancestorRecords[1].seq
        #shutil.rmtree(os.path.join('WORK', str(folder_id)))
        
        #s_ancestor = residue_constants.str_to_aatype(ancestor_str)
        #y['ancestor_seq'] = torch.tensor([s_ancestor], dtype=torch.float32, device=y['aatype'].device)
        
        s_truth = y['label_seq'][0].int().tolist()
        s_ancestor = y['ancestor_seq'][0].int().tolist()

        mask_substitutions_ancestor = [s_ancestor[i]!=s_truth[i] for i in range(len(s_ancestor))]
        y['mask_substitutions_ancestor'] = torch.tensor([mask_substitutions_ancestor], dtype=torch.int64, device=y['aatype'].device)
        
        aatype_str = residue_constants.aatype_to_str_sequence(y['anchor_seq'][0].int().tolist())
        mask_indels = np.array([s_truth[i] != 21 for i in range(len(s_truth))])
        y['mask_indels'] = torch.tensor(mask_indels[None,:], dtype=torch.bool)
        
        crop_size = self.datasets[dataset_idx].config[self.datasets[dataset_idx].mode].crop_size
        y_cropped = self.crop_data(y, crop_size)
        y_cropped = self.add_masks_and_subst_rates(y_cropped)
        y_cropped_widened = self.widen_loaded_data(y_cropped, 1)
        return y_cropped_widened

    def add_masks_and_subst_rates(self, y):
        # compute the merged mask and the substitution rates according to the crop
        label_seq = y['label_seq']
        seq_len = label_seq.size()[0]
        seq_length_crop = y['seq_length_crop']
        mask_indels = y['mask_indels']
        mask_crop = torch.zeros(seq_len).to(mask_indels.device)
        mask_crop[:seq_length_crop] = torch.ones((1,seq_length_crop.item()))
        merged_mask = torch.logical_and(mask_crop.bool(), mask_indels.bool())
    
        s_ancestor = y['ancestor_seq']
        s_truth = y['label_seq']
        s_musca = y['musca_seq']

        # compute subst rate between truth (beaver) and ancestor
        m_len = sum([s_truth[i]!=21 and s_ancestor[i]!=21 and mask_crop[i]==1 for i in range(len(s_ancestor))])
        subst_rate = sum([s_truth[i] != s_ancestor[i] and s_truth[i]!=21 and s_ancestor[i]!=21 and mask_crop[i]==1 for i in range(len(s_ancestor))]) / m_len
        subst_rate = torch.tensor([subst_rate]).to(y['ancestor_seq'].device)
        
        # add features to y
        y['merged_mask'] = merged_mask
        y['subst_rate'] = subst_rate

        return y

    
    def crop_data(self, y, crop_size):    # data are full sequence length, we need to crop them to use them in the network
        y_c = {}
        seq_length = y['seq_length'].item()
        y_c['seq_length'] = y['seq_length'][:,None]
        if seq_length > crop_size:    # crop
            start_bound = random.randint(0, seq_length-crop_size-1)
            end_bound = start_bound+crop_size
            y_c['output_msa'] = y['output_msa'][:,:,start_bound:end_bound,:]
            y_c['output_pair'] = y['output_pair'][:,start_bound:end_bound,start_bound:end_bound,:]
            y_c['output_single'] = y['output_single'][:,start_bound:end_bound,:]
            y_c['aatype'] = y['aatype'][:,start_bound:end_bound]
            y_c['seq_mask'] = y['seq_mask'][:,start_bound:end_bound]
            y_c['msa_mask'] = y['msa_mask'][:,:,start_bound:end_bound]
            y_c['anchor_seq'] = y['anchor_seq'][:,start_bound:end_bound]
            y_c['musca_seq'] = y['musca_seq'][:,start_bound:end_bound]
            y_c['label_seq'] = y['label_seq'][:,start_bound:end_bound]
            y_c['human_seq'] = y['human_seq'][:,start_bound:end_bound]
            y_c['mouse_seq'] = y['mouse_seq'][:,start_bound:end_bound]
            y_c['ancestor_seq'] = y['ancestor_seq'][:,start_bound:end_bound]
            y_c['residue_index'] = y['residue_index'][:,start_bound:end_bound]
            y_c['residue_index_rev'] = y['residue_index_rev'][:,start_bound:end_bound]
            y_c['msa_feat'] = y['msa_feat'][:,:,start_bound:end_bound,:]
            y_c['target_feat'] = y['target_feat'][:,start_bound:end_bound,:]
            y_c['mask_substitutions'] = y['mask_substitutions'][:,start_bound:end_bound]
            y_c['mask_substitutions_ancestor'] = y['mask_substitutions_ancestor'][:,start_bound:end_bound]
            y_c['mask_indels'] = y['mask_indels'][:,start_bound:end_bound]
            y_c['seq_length_crop'] = torch.tensor([crop_size])[:,None].long()
        else:    # expand
            s = y['output_msa'].size()
            y_output_msa = torch.zeros(s[0], s[1], crop_size, s[3])
            y_output_msa[:,:,:s[2],:] = y['output_msa']
            y_c['output_msa'] = y_output_msa
            
            s = y['output_pair'].size()
            y_output_pair = torch.zeros(s[0], crop_size, crop_size, s[3])
            y_output_pair[:,:s[1],:s[2],:] = y['output_pair']
            y_c['output_pair'] = y_output_pair
            
            s = y['output_single'].size()
            y_output_single = torch.zeros(s[0], crop_size, s[2])
            y_output_single[:,:s[1],:] = y['output_single']
            y_c['output_single'] = y_output_single
            
            s = y['aatype'].size()
            y_aatype = torch.zeros(s[0], crop_size)
            y_aatype[:,:s[1]] = y['aatype']
            y_c['aatype'] = y_aatype
            
            s = y['seq_mask'].size()
            y_seq_mask = torch.zeros(s[0], crop_size)
            y_seq_mask[:,:s[1]] = y['seq_mask']
            y_c['seq_mask'] = y_seq_mask
            
            s = y['msa_mask'].size()
            y_msa_mask = torch.zeros(s[0], s[1], crop_size)
            y_msa_mask[:,:,:s[2]] = y['msa_mask']
            y_c['msa_mask'] = y_msa_mask
            
            s = y['anchor_seq'].size()
            y_anchor_seq = torch.zeros(s[0], crop_size)
            y_anchor_seq[:,:s[1]] = y['anchor_seq']
            y_c['anchor_seq'] = y_anchor_seq
            
            s = y['musca_seq'].size()
            y_musca_seq = torch.zeros(s[0], crop_size)
            y_musca_seq[:,:s[1]] = y['musca_seq']
            y_c['musca_seq'] = y_musca_seq
            
            s = y['label_seq'].size()
            y_label_seq = torch.zeros(s[0], crop_size)
            y_label_seq[:,:s[1]] = y['label_seq']
            y_c['label_seq'] = y_label_seq
            
            s = y['human_seq'].size()
            y_human_seq = torch.zeros(s[0], crop_size)
            y_human_seq[:,:s[1]] = y['human_seq']
            y_c['human_seq'] = y_human_seq
            
            s = y['mouse_seq'].size()
            y_mouse_seq = torch.zeros(s[0], crop_size)
            y_mouse_seq[:,:s[1]] = y['mouse_seq']
            y_c['mouse_seq'] = y_mouse_seq
            
            s = y['ancestor_seq'].size()
            y_ancestor_seq = torch.zeros(s[0], crop_size)
            y_ancestor_seq[:,:s[1]] = y['ancestor_seq']
            y_c['ancestor_seq'] = y_ancestor_seq
            
            s = y['residue_index'].size()
            y_residue_index = torch.zeros(s[0], crop_size)
            y_residue_index[:,:s[1]] = y['residue_index']
            y_c['residue_index'] = y_residue_index
            
            s = y['residue_index_rev'].size()
            y_residue_index_rev = torch.zeros(s[0], crop_size)
            y_residue_index_rev[:,:s[1]] = y['residue_index_rev']
            y_c['residue_index_rev'] = y_residue_index_rev
            
            s = y['msa_feat'].size()
            y_msa_feat = torch.zeros(s[0], s[1], crop_size, s[3])
            y_msa_feat[:,:,:s[2],:] = y['msa_feat']
            y_c['msa_feat'] = y_msa_feat

            s = y['target_feat'].size()
            y_target_feat = torch.zeros(s[0], crop_size, s[2])
            y_target_feat[:,:s[1],:] = y['target_feat']
            y_c['target_feat'] = y_target_feat

            s = y['mask_substitutions'].size()
            y_mask_substitutions = torch.zeros(s[0], crop_size)
            y_mask_substitutions[:,:s[1]] = y['mask_substitutions']
            y_c['mask_substitutions'] = y_mask_substitutions
            
            s = y['mask_substitutions_ancestor'].size()
            y_mask_substitutions_ancestor = torch.zeros(s[0], crop_size)
            y_mask_substitutions_ancestor[:,:s[1]] = y['mask_substitutions_ancestor']
            y_c['mask_substitutions_ancestor'] = y_mask_substitutions_ancestor

            s = y['mask_indels'].size()
            y_mask_indels = torch.zeros(s[0], crop_size)
            y_mask_indels[:,:s[1]] = y['mask_indels']
            y_c['mask_indels'] = y_mask_indels
            
            y_c['seq_length_crop'] = y_c['seq_length'].long()

        y_c['mask_substitutions'] = y_c['mask_substitutions'].long()
        y_c['mask_substitutions_ancestor'] = y_c['mask_substitutions_ancestor'].long()
        #y_c['mask_indels'] = y_c['mask_indels'].long()
        
        for k in y_c.keys():
            y_c[k] = y_c[k][0]
        return y_c
    
    def widen_loaded_data(self, y, size):
        y_wide = {}
        for k in y.keys():
            if y[k].size()[-1]==1:
                y_wide[k] = y[k].expand(*(y[k].size()[:-1]), size)
            else:
                y_tmp = (y[k])[...,None]
                y_wide[k] = y_tmp.expand(*(y_tmp.size()[:-1]), size)
        return y_wide
        
    def __len__(self):
        return self.epoch_len

    def reroll(self):
        dataset_choices = torch.multinomial(
            torch.tensor(self.probabilities),
            num_samples=self.epoch_len,
            replacement=True,
            generator=self.generator,
        )

        self._samples = [self.looped_shuffled_dataset_idx(d) for d in self.dataset_raw_lengths]    # shuffle the samples
        self.datapoints = []
        for dataset_idx in dataset_choices:
            samples = self._samples[dataset_idx]
            datapoint_idx = next(samples)
            self.datapoints.append((dataset_idx.item(), datapoint_idx.item()))


class OpenFoldBatchCollator:
    def __call__(self, prots):
        stack_fn = partial(torch.stack, dim=0)
        return dict_multimap(stack_fn, prots) 


class OpenFoldDataLoader(torch.utils.data.DataLoader):
    def __init__(self, *args, config, stage="train", generator=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.config = config
        self.stage = stage
        self.generator = generator
        self._prep_batch_properties_probs()

    def _prep_batch_properties_probs(self):
        keyed_probs = []
        stage_cfg = self.config[self.stage]

        max_iters = self.config.common.max_recycling_iters
        
        if(stage_cfg.uniform_recycling):
            recycling_probs = [
                1. / (max_iters + 1) for _ in range(max_iters + 1)
            ]
        else:
            recycling_probs = [
                0. for _ in range(max_iters + 1)
            ]
            recycling_probs[-1] = 1.
        
        keyed_probs.append(
            ("no_recycling_iters", recycling_probs)
        )

        keys, probs = zip(*keyed_probs)
        max_len = max([len(p) for p in probs])
        padding = [[0.] * (max_len - len(p)) for p in probs] 
        
        self.prop_keys = keys
        self.prop_probs_tensor = torch.tensor(
            [p + pad for p, pad in zip(probs, padding)],
            dtype=torch.float32,
        )

    def _add_batch_properties(self, batch):
        samples = torch.multinomial(
            self.prop_probs_tensor,
            num_samples=1, # 1 per row
            replacement=True,
            generator=self.generator
        )

        aatype = batch["aatype"]
        batch_dims = aatype.shape[:-2]
        recycling_dim = aatype.shape[-1]
        no_recycling = recycling_dim
        for i, key in enumerate(self.prop_keys):
            sample = int(samples[i][0])
            sample_tensor = torch.tensor(
                sample, 
                device=aatype.device, 
                requires_grad=False
            )
            orig_shape = sample_tensor.shape
            sample_tensor = sample_tensor.view(
                (1,) * len(batch_dims) + sample_tensor.shape + (1,)
            )
            sample_tensor = sample_tensor.expand(
                batch_dims + orig_shape + (recycling_dim,)
            )
            batch[key] = sample_tensor

            if(key == "no_recycling_iters"):
                no_recycling = sample 
        
        resample_recycling = lambda t: t[..., :no_recycling + 1]
        batch = tensor_tree_map(resample_recycling, batch)

        return batch

    def __iter__(self):
        it = super().__iter__()

        def _batch_prop_gen(iterator):
            for batch in iterator:
                yield self._add_batch_properties(batch)

        return _batch_prop_gen(it)


class OpenFoldDataModule(pl.LightningDataModule):
    def __init__(self,
        config: mlc.ConfigDict,
        template_mmcif_dir: str,
        max_template_date: str,
        #train_data_dir: Optional[str] = None,
        train_alignment_dir: Optional[str] = None,
        train_chain_data_cache_path: Optional[str] = None,
        eval_chain_data_cache_path: Optional[str] = None,    # RAPH
        distillation_data_dir: Optional[str] = None,
        distillation_alignment_dir: Optional[str] = None,
        distillation_chain_data_cache_path: Optional[str] = None,
        val_data_dir: Optional[str] = None,
        val_alignment_dir: Optional[str] = None,
        predict_data_dir: Optional[str] = None,
        predict_alignment_dir: Optional[str] = None,
        kalign_binary_path: str = '/usr/bin/kalign',
        train_filter_path: Optional[str] = None,
        distillation_filter_path: Optional[str] = None,
        obsolete_pdbs_file_path: Optional[str] = None,
        template_release_dates_cache_path: Optional[str] = None,
        batch_seed: Optional[int] = None,
        train_epoch_len: int = 50000, 
        eval_epoch_len: int = 50000,    # RAPH
        _distillation_structure_index_path: Optional[str] = None,
        alignment_index_path: Optional[str] = None,
        distillation_alignment_index_path: Optional[str] = None,
        precomputed_data_dir_train: Optional[str] = None,
        precomputed_data_dir_eval: Optional[str] = None,
        #label_dir: Optional[str] = None,    # RAPH
        #anchor_dir: Optional[str] = None,    # RAPH
        #precomputed_dir: Optional[str] = None,    # RAPH
        **kwargs
    ):
        super(OpenFoldDataModule, self).__init__()

        self.config = config
        #self.template_mmcif_dir = template_mmcif_dir
        self.max_template_date = max_template_date
        #self.train_data_dir = train_data_dir
        #self.train_alignment_dir = train_alignment_dir
        #self.train_chain_data_cache_path = train_chain_data_cache_path
        self.distillation_data_dir = distillation_data_dir
        self.distillation_alignment_dir = distillation_alignment_dir
        self.distillation_chain_data_cache_path = (
            distillation_chain_data_cache_path
        )
        #self.val_data_dir = val_data_dir
        #self.val_alignment_dir = val_alignment_dir
        self.predict_data_dir = predict_data_dir
        self.predict_alignment_dir = predict_alignment_dir
        self.kalign_binary_path = kalign_binary_path
        self.train_filter_path = train_filter_path
        self.distillation_filter_path = distillation_filter_path
        self.template_release_dates_cache_path = (
            template_release_dates_cache_path
        )
        self.obsolete_pdbs_file_path = obsolete_pdbs_file_path
        self.batch_seed = batch_seed
        self.train_epoch_len = train_epoch_len

        
        # RAPH: dirs for label and anchor and stuff to deal with eval epoch_len
        #self.label_dir = label_dir
        #self.anchor_dir = anchor_dir
        self.precomputed_data_dir_train = precomputed_data_dir_train
        self.precomputed_data_dir_eval = precomputed_data_dir_eval
        self.eval_epoch_len = eval_epoch_len
        #self.eval_chain_data_cache_path = eval_chain_data_cache_path

        if(self.precomputed_data_dir_train is None or self.precomputed_data_dir_eval is None):
            raise ValueError(
                'precomputed_data_dir_train and precomputed_data_dir_eval must be '
                'specified'
            )

        self.training_mode = self.precomputed_data_dir_train is not None

        #if(self.training_mode and train_alignment_dir is None):
        #    raise ValueError(
        #        'In training mode, train_alignment_dir must be specified'
        #    )
        #elif(not self.training_mode and predict_alignment_dir is None):
        #    raise ValueError(
        #        'In inference mode, predict_alignment_dir must be specified'
        #    )      
        #elif(val_data_dir is not None and val_alignment_dir is None):
        #    raise ValueError(
        #        'If val_data_dir is specified, val_alignment_dir must '
        #        'be specified as well'
        #)

        # An ad-hoc measure for our particular filesystem restrictions
        self._distillation_structure_index = None
        if(_distillation_structure_index_path is not None):
            with open(_distillation_structure_index_path, "r") as fp:
                self._distillation_structure_index = json.load(fp)
        
        self.alignment_index = None
        if(alignment_index_path is not None):
            with open(alignment_index_path, "r") as fp:
                self.alignment_index = json.load(fp)

        self.distillation_alignment_index = None
        if(distillation_alignment_index_path is not None):
            with open(distillation_alignment_index_path, "r") as fp:
                self.distillation_alignment_index = json.load(fp)

    def setup(self):
        # Most of the arguments are the same for the three datasets 
        dataset_gen = partial(OpenFoldSingleDataset,
        #    template_mmcif_dir=self.template_mmcif_dir,
            max_template_date=self.max_template_date,
        #    label_dir=self.label_dir,    # RAPH
        #    anchor_dir=self.anchor_dir,    # RAPH
        #    precomputed_dir=self.precomputed_dir,    # RAPH
            config=self.config,
            kalign_binary_path=self.kalign_binary_path,
            template_release_dates_cache_path=
                self.template_release_dates_cache_path,
            obsolete_pdbs_file_path=
                self.obsolete_pdbs_file_path,
        )

        if(self.training_mode):
            train_dataset = dataset_gen(
                precomputed_data_dir=self.precomputed_data_dir_train,
                #chain_data_cache_path=self.train_chain_data_cache_path,
                #alignment_dir=self.train_alignment_dir,
                filter_path=self.train_filter_path,
                max_template_hits=self.config.train.max_template_hits,
                #shuffle_top_k_prefiltered=
                #    self.config.train.shuffle_top_k_prefiltered,
                treat_pdb_as_distillation=False,
                mode="train",
                alignment_index=self.alignment_index,
            )

            distillation_dataset = None
            if(self.distillation_data_dir is not None):
                distillation_dataset = dataset_gen(
                    data_dir=self.distillation_data_dir,
                    chain_data_cache_path=self.distillation_chain_data_cache_path,
                    alignment_dir=self.distillation_alignment_dir,
                    filter_path=self.distillation_filter_path,
                    max_template_hits=self.config.train.max_template_hits,
                    treat_pdb_as_distillation=True,
                    mode="train",
                    alignment_index=self.distillation_alignment_index,
                    _structure_index=self._distillation_structure_index,
                )

                d_prob = self.config.train.distillation_prob
        
            if(distillation_dataset is not None):
                datasets = [train_dataset, distillation_dataset]
                d_prob = self.config.train.distillation_prob
                probabilities = [1. - d_prob, d_prob]
            else:
                datasets = [train_dataset]
                probabilities = [1.]

            generator = None
            if(self.batch_seed is not None):
                generator = torch.Generator()
                generator = generator.manual_seed(self.batch_seed + 1)
            
            self.train_dataset = OpenFoldDataset(
                datasets=datasets,
                probabilities=probabilities,
                epoch_len=self.train_epoch_len,
                generator=generator,
                _roll_at_init=False,
            )
    
            #if(self.val_data_dir is not None):
            if(self.precomputed_data_dir_eval is not None):
                # RAPH: change dataset to OpenFoldDataset instead of OpenFoldSingleDataset to control eval epoch_len
                eval_dataset = dataset_gen(
                    precomputed_data_dir=self.precomputed_data_dir_eval,
                    #chain_data_cache_path=self.eval_chain_data_cache_path,
                    #alignment_dir=self.val_alignment_dir,
                    filter_path=None,
                    max_template_hits=self.config.eval.max_template_hits,
                    mode="eval",
                )
                datasets_eval = [eval_dataset]
                probabilities = [1.]
                generator = None
                if(self.batch_seed is not None):
                    generator = torch.Generator()
                    generator = generator.manual_seed(self.batch_seed + 1)
                self.eval_dataset = OpenFoldDataset(
                    datasets=datasets_eval,
                    probabilities=probabilities,
                    epoch_len=self.eval_epoch_len,
                    generator=generator,
                    _roll_at_init=False,
                )
                # RAPH: the eval dataset is not done and we can use eval_epoch_len on it
            else:
                self.eval_dataset = None
        else:           
            self.predict_dataset = dataset_gen(
                data_dir=self.predict_data_dir,
                alignment_dir=self.predict_alignment_dir,
                filter_path=None,
                max_template_hits=self.config.predict.max_template_hits,
                mode="predict",
            )

    def _gen_dataloader(self, stage):
        generator = None
        if(self.batch_seed is not None):
            generator = torch.Generator()
            generator = generator.manual_seed(self.batch_seed)

        dataset = None
        #num_workers = 0    # RAPH: set manually the number of workers due to an issue on multiple workers for eval set
        if(stage == "train"):
            dataset = self.train_dataset
            #num_workers = self.config.data_module.data_loaders.num_workers
            # Filter the dataset, if necessary
            dataset.reroll()
        elif(stage == "eval"):
            dataset = self.eval_dataset
            dataset.reroll()    # RAPH: reroll to shuffle data
        elif(stage == "predict"):
            dataset = self.predict_dataset
        else:
            raise ValueError("Invalid stage")

        batch_collator = OpenFoldBatchCollator()
        
        dl = OpenFoldDataLoader(
            dataset,
            config=self.config,
            stage=stage,
            generator=generator,
            batch_size=self.config.data_module.data_loaders.batch_size,
            num_workers=self.config.data_module.data_loaders.num_workers,
            #num_workers=num_workers,
            collate_fn=batch_collator,
        )

        return dl

    def train_dataloader(self):
        return self._gen_dataloader("train") 

    def val_dataloader(self):
        if(self.eval_dataset is not None):
            return self._gen_dataloader("eval")
        return None

    def predict_dataloader(self):
        return self._gen_dataloader("predict") 


class DummyDataset(torch.utils.data.Dataset):
    def __init__(self, batch_path):
        with open(batch_path, "rb") as f:
            self.batch = pickle.load(f)

    def __getitem__(self, idx):
        return copy.deepcopy(self.batch)

    def __len__(self):
        return 1000


class DummyDataLoader(pl.LightningDataModule):
    def __init__(self, batch_path):
        super().__init__()
        self.dataset = DummyDataset(batch_path)

    def train_dataloader(self):
        return torch.utils.data.DataLoader(self.dataset)
